"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupChatwootOutgoingMessageHandler = exports.chatwootMiddleware = void 0;
const axios_1 = __importDefault(require("axios"));
const form_data_1 = __importDefault(require("form-data"));
const mime_types_1 = __importDefault(require("mime-types"));
const chatwootMiddleware = (cliConfig, client) => {
    return (req, res) => __awaiter(void 0, void 0, void 0, function* () {
        const processMesssage = () => __awaiter(void 0, void 0, void 0, function* () {
            const promises = [];
            const { body } = req;
            if (!body)
                return;
            if (!body.conversation)
                return;
            const m = body.conversation.messages[0];
            const contact = (body.conversation.meta.sender.phone_number || "").replace('+', '');
            if (body.message_type === "incoming" ||
                body.private ||
                body.event !== "message_created" ||
                !m ||
                !contact)
                return;
            const { attachments, content } = m;
            const to = `${contact}@c.us`;
            if ((attachments === null || attachments === void 0 ? void 0 : attachments.length) > 0) {
                //has attachments
                const [firstAttachment, ...restAttachments] = attachments;
                const sendAttachment = (attachment, c) => __awaiter(void 0, void 0, void 0, function* () { return client.sendImage(to, attachment.data_url, attachment.data_url.substring(attachment.data_url.lastIndexOf('/') + 1), c || '', null, true); });
                //send the text as the caption with the first message only
                promises.push(sendAttachment(firstAttachment, content));
                restAttachments.map(sendAttachment).map(promises.push);
            }
            else {
                //no attachments
                if (!content)
                    return;
                /**
                 * Check if this is a location message
                 */
                const locationMatcher = /@(\-*\d*\.*\d*\,\-*\d*\.*\d*)/g;
                const [possLoc, ...restMessage] = content.split(' ');
                const locArr = possLoc.match(locationMatcher);
                if (locArr) {
                    const [lat, lng] = locArr[0].split(',');
                    //grab the location message
                    const loc = restMessage.join(' ') || '';
                    promises.push(client.sendLocation(to, lat, lng, loc));
                }
                else {
                    //not a location message
                    promises.push(client.sendText(to, content));
                }
            }
            return yield Promise.all(promises);
        });
        try {
            const processAndSendResult = yield processMesssage();
            res.status(200).send(processAndSendResult);
        }
        catch (error) {
            console.log("ðŸš€ ~ file: chatwoot.ts ~ line 62 ~ return ~ error", error);
            res.status(400).send(error);
        }
        return;
    });
};
exports.chatwootMiddleware = chatwootMiddleware;
const setupChatwootOutgoingMessageHandler = (cliConfig, client) => __awaiter(void 0, void 0, void 0, function* () {
    const u = cliConfig.chatwootUrl; //e.g `"localhost:3000/api/v1/accounts/3"
    const api_access_token = cliConfig.chatwootApiAccessToken;
    const _u = new URL(u);
    const origin = _u.origin;
    const port = _u.port || 80;
    const [accountId, inboxId] = u.match(/\/(app|(api\/v1))\/accounts\/\d*\/(inbox|inboxes)\/\d*/g)[0].split('/').filter(Number);
    // const accountId = u.match(/accounts\/\d*/g) && u.match(/accounts\/\d*/g)[0].replace('accounts/', '')
    const resolvedInbox = inboxId || u.match(/inboxes\/\d*/g) && u.match(/inboxes\/\d*/g)[0].replace('inboxes/', '');
    const cwReq = (path, method, data, _headers) => {
        const url = `${origin}/api/v1/accounts/${accountId}/${path}`.replace('app.bentonow.com', 'chat.bentonow.com');
        // console.log(url,method,data)
        return (0, axios_1.default)({
            method,
            data,
            url,
            headers: Object.assign({ api_access_token }, _headers)
        });
    };
    const contactReg = {
        //WID : chatwoot contact ID
        "example@c.us": "1"
    };
    const convoReg = {
        //WID : chatwoot conversation ID
        "example@c.us": "1"
    };
    const { data: get_inbox } = yield cwReq(`inboxes/${resolvedInbox}`, 'get');
    // const inboxId = `openwa_${sessionId}`
    /**
     * Get the inbox and test it.
     */
    if (!((get_inbox === null || get_inbox === void 0 ? void 0 : get_inbox.webhook_url) || "").includes("/chatwoot"))
        console.log("Please set the chatwoot inbox webhook to this sessions URL with path /chatwoot");
    /**
     * Get Contacts and conversations
     */
    const searchContact = (number) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const n = number.replace('@c.us', '');
            const { data } = yield cwReq(`contacts/search?q=${n}&sort=phone_number`, 'get');
            if (data.payload.length) {
                return data.payload.find(x => (x.phone_number || "").includes(n)) || false;
            }
            else
                false;
        }
        catch (error) {
            return;
        }
    });
    const getContactConversation = (number) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { data } = yield cwReq(`contacts/${contactReg[number]}/conversations`, 'get');
            return data.payload.sort((a, b) => a.id - b.id)[0];
        }
        catch (error) {
            return;
        }
    });
    const createConversation = (contact_id) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { data } = yield cwReq(`conversations`, 'post', {
                contact_id,
                "inbox_id": resolvedInbox
            });
            return data;
        }
        catch (error) {
            return;
        }
    });
    const createContact = (contact) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { data } = yield cwReq(`contacts`, 'post', {
                "identifier": contact.id,
                "name": contact.formattedName || contact.id,
                "phone_number": `+${contact.id.replace('@c.us', '')}`,
                "avatar_url": contact.profilePicThumbObj.eurl
            });
            return data.payload.contact;
        }
        catch (error) {
            return;
        }
    });
    const sendConversationMessage = (content, contactId, message) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { data } = yield cwReq(`conversations/${convoReg[contactId]}/messages`, 'post', {
                content,
                "message_type": 0,
                "private": false
            });
            return data;
        }
        catch (error) {
            return;
        }
    });
    const sendAttachmentMessage = (content, contactId, message) => __awaiter(void 0, void 0, void 0, function* () {
        // decrypt message
        const file = yield client.decryptMedia(message);
        let formData = new form_data_1.default();
        formData.append('attachments[]', Buffer.from(file.split(',')[1], 'base64'), {
            knownLength: 1,
            filename: `${message.t}.${mime_types_1.default.extension(message.mimetype)}`,
            contentType: (file.match(/[^:\s*]\w+\/[\w-+\d.]+(?=[;| ])/) || ["application/octet-stream"])[0]
        });
        formData.append('content', content);
        formData.append('message_type', 'incoming');
        try {
            const { data } = yield cwReq(`conversations/${convoReg[contactId]}/messages`, 'post', formData, formData.getHeaders());
            return data;
        }
        catch (error) {
            return;
        }
    });
    // const inboxId = s.match(/conversations\/\d*/g) && s.match(/conversations\/\d*/g)[0].replace('conversations/','')
    /**
     * Update the chatwoot contact and conversation registries
     */
    client.onMessage((message) => __awaiter(void 0, void 0, void 0, function* () {
        if (message.from.includes('g')) {
            //chatwoot integration does not support group chats
            return;
        }
        /**
         * Does the contact exist in chatwoot?
         */
        if (!contactReg[message.from]) {
            const contact = yield searchContact(message.from);
            if (contact) {
                contactReg[message.from] = contact.id;
            }
            else {
                //create the contact
                contactReg[message.from] = (yield createContact(message.sender)).id;
            }
        }
        if (!convoReg[message.from]) {
            const conversation = yield getContactConversation(message.from);
            if (conversation) {
                convoReg[message.from] = conversation.id;
            }
            else {
                //create the conversation
                convoReg[message.from] = (yield createConversation(contactReg[message.from])).id;
            }
        }
        /**
         * Does the conversation exist in
         */
        let text = message.body;
        let hasAttachments = false;
        switch (message.type) {
            case 'location':
                text = `${message.lat},${message.lng}`;
                break;
            case 'buttons_response':
                text = message.selectedButtonId;
                break;
            case 'document':
            case 'image':
            case 'audio':
            case 'ptt':
            case 'video':
                if (message.cloudUrl) {
                    text = `FILE:\t${message.cloudUrl}\n\nMESSAGE:\t${message.text}`;
                }
                else {
                    text = message.text;
                    hasAttachments = true;
                }
                break;
            default:
                text = message.body || "__UNHANDLED__";
                break;
        }
        if (hasAttachments)
            yield sendAttachmentMessage(text, message.from, message);
        else
            yield sendConversationMessage(text, message.from, message);
    }));
});
exports.setupChatwootOutgoingMessageHandler = setupChatwootOutgoingMessageHandler;
