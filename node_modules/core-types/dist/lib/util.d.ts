import { NodeType, PrimitiveType, NodeWithConstEnum, Types, NodeTypeMap, NamedType, NodeDocument } from "./types";
export declare function uniq<T extends Comparable | unknown>(arr: Array<T>): Array<T>;
export declare function ensureArray<T>(t: T | Array<T> | undefined | null): Array<T>;
export declare const isPrimitiveType: (node: NodeType) => node is PrimitiveType;
export declare const constEnumTypes: Set<"string" | "number" | "boolean" | "object" | "integer" | "and" | "or" | "ref" | "any" | "null" | "array" | "tuple">;
export declare const hasConstEnum: (node: NodeType) => node is NodeWithConstEnum;
export declare type ComparablePrimitives = undefined | null | boolean | string | number;
export declare type ComparableArray = Array<Comparable>;
export declare type ComparableObject = {
    [key: string]: Comparable;
};
export declare type Comparable = ComparablePrimitives | ComparableArray | ComparableObject;
export declare function isEqual<T extends Comparable>(a: T, b: T): boolean;
export declare function isEqual<T extends Comparable, U extends Comparable>(a: T, b: U): false;
export declare function intersection<T extends Comparable>(a: Array<T>, b: Array<T>): Array<T>;
export declare function union<T extends Comparable>(a: Array<T>, b: Array<T>): Array<T>;
export interface NodeWithOrder<T> {
    node: T;
    order: number;
}
declare type SplitTypes = {
    [T in Types]: Array<NodeWithOrder<NodeTypeMap[T]>>;
};
export declare function splitTypes(nodes: Array<NodeType>): SplitTypes;
export declare function flattenSplitTypeValues(splitTypes: SplitTypes): NodeType[];
export declare function firstSplitTypeIndex(nodes: Array<NodeWithOrder<unknown>>): number;
export declare function copyName(from: NamedType<any>, to: NamedType<any>): typeof to;
export declare function isNonNullable<T>(t: T): t is NonNullable<T>;
export declare function isNodeDocument(t: NodeDocument | NodeType | Array<NodeType>): t is NodeDocument;
export {};
