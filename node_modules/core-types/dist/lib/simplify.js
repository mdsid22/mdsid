"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simplify = void 0;
const single_1 = require("./simplifications/single");
const const_enum_1 = require("./simplifications/const-enum");
const intersect_const_enum_1 = require("./simplifications/intersect-const-enum");
const error_1 = require("./error");
const annotation_1 = require("./annotation");
const util_1 = require("./util");
const enumableTypeNames = [
    'any',
    'string',
    'number',
    'integer',
    'boolean',
];
function simplify(node) {
    if (Array.isArray(node))
        return node.map(node => simplify(node));
    if ((0, util_1.isNodeDocument)(node))
        return {
            ...node,
            types: simplify(node.types),
        };
    const wrapName = (newNode) => (0, util_1.copyName)(node, newNode);
    if (node.type === 'tuple') {
        return {
            ...node,
            elementTypes: node.elementTypes.map(type => simplify(type)),
            ...(node.additionalItems &&
                typeof node.additionalItems === 'object'
                ? { additionalItems: simplify(node.additionalItems) }
                : {}),
        };
    }
    else if (node.type === 'array') {
        return {
            ...node,
            elementType: simplify(node.elementType)
        };
    }
    else if (node.type === 'object') {
        return {
            ...node,
            properties: Object.fromEntries(Object.entries(node.properties)
                .map(([name, { node, required }]) => [name, { node: simplify(node), required }])),
            ...(node.additionalProperties &&
                typeof node.additionalProperties === 'object'
                ? {
                    additionalProperties: simplify(node.additionalProperties)
                }
                : {}),
        };
    }
    else if (node.type !== 'and' && node.type !== 'or')
        return wrapName((0, single_1.simplifySingle)(node));
    else if (node.type === 'and') {
        const and = simplifyIntersection([].concat(...node.and.map(node => {
            const simplifiedNode = simplify(node);
            return simplifiedNode.and
                ? simplifiedNode.and
                : [simplifiedNode];
        })));
        if (and.length === 1)
            return wrapName({
                ...and[0],
                ...(0, annotation_1.mergeAnnotations)([(0, annotation_1.extractAnnotations)(node), and[0]])
            });
        return wrapName({ type: 'and', and, ...(0, annotation_1.extractAnnotations)(node) });
    }
    else if (node.type === 'or') {
        const or = simplifyUnion([].concat(...node.or.map(node => {
            const simplifiedNode = simplify(node);
            return simplifiedNode.or
                ? simplifiedNode.or
                : [simplifiedNode];
        })));
        if (or.length === 1)
            return wrapName({
                ...or[0],
                ...(0, annotation_1.mergeAnnotations)([(0, annotation_1.extractAnnotations)(node), or[0]])
            });
        return wrapName({ type: 'or', or, ...(0, annotation_1.extractAnnotations)(node) });
    }
    else {
        // istanbul ignore next
        throw new error_1.MalformedTypeError("Invalid node", node);
    }
}
exports.simplify = simplify;
// Combine types/nodes where one is more generic than some other, or where
// they can be combined to fewer nodes.
function simplifyUnion(nodes) {
    const typeMap = (0, util_1.splitTypes)(nodes);
    if (typeMap.any.length > 0) {
        const enums = (0, const_enum_1.mergeConstEnumUnion)(typeMap.any.map(({ node }) => node));
        if (enums.length === 0)
            // If any type in a set of types is an "any" type, without const
            // or enum, the whole union is "any".
            return [{
                    type: 'any',
                    ...(0, annotation_1.mergeAnnotations)(typeMap.any.map(({ node }) => node)),
                }];
    }
    for (const [_typeName, _types] of Object.entries(typeMap)) {
        const typeName = _typeName;
        if (!enumableTypeNames.includes(typeName) || !_types.length)
            continue;
        const orderedTypes = _types;
        const types = orderedTypes.map(({ node }) => node);
        const merged = (0, const_enum_1.mergeConstEnumUnion)(types);
        if (merged.length === 0)
            typeMap[typeName] = [{
                    node: {
                        type: typeName,
                        ...(0, annotation_1.mergeAnnotations)(types),
                    },
                    order: (0, util_1.firstSplitTypeIndex)(orderedTypes),
                }];
        else
            typeMap[typeName] = [{
                    node: (0, single_1.simplifySingle)({
                        type: typeName,
                        enum: merged,
                        ...(0, annotation_1.mergeAnnotations)(types),
                    }),
                    order: (0, util_1.firstSplitTypeIndex)(orderedTypes),
                }];
    }
    if (typeMap.or.length > 0)
        typeMap.or = typeMap.or.filter(({ node }) => node.or.length > 0);
    if (typeMap.and.length > 0)
        typeMap.and = typeMap.and
            .filter(({ node }) => node.and.length > 0);
    return (0, util_1.flattenSplitTypeValues)(typeMap);
}
// Combine types/nodes and exclude types, const and enum where other are
// narrower/stricter.
function simplifyIntersection(nodes) {
    const typeMap = (0, util_1.splitTypes)(nodes);
    if (typeMap.any.length > 0) {
        if (typeMap.and.length === 0 &&
            typeMap.or.length === 0 &&
            typeMap.ref.length === 0 &&
            typeMap.null.length === 0 &&
            typeMap.string.length === 0 &&
            typeMap.number.length === 0 &&
            typeMap.integer.length === 0 &&
            typeMap.boolean.length === 0 &&
            typeMap.object.length === 0 &&
            typeMap.array.length === 0 &&
            typeMap.tuple.length === 0)
            return [{
                    type: 'any',
                    ...(0, annotation_1.mergeAnnotations)(typeMap.any.map(({ node }) => node)),
                }];
        else
            // A more precise type will supercede this
            typeMap.any = [];
    }
    const cast = (nodes) => nodes.map(({ node }) => node);
    if (typeMap.boolean.length > 1)
        typeMap.boolean = [{
                node: (0, intersect_const_enum_1.intersectConstEnum)([
                    ...typeMap.boolean.map(({ node }) => node),
                    ...cast(typeMap.any),
                ]),
                order: (0, util_1.firstSplitTypeIndex)(typeMap.boolean),
            }];
    if (typeMap.string.length > 1)
        typeMap.string = [{
                node: (0, intersect_const_enum_1.intersectConstEnum)([
                    ...typeMap.string.map(({ node }) => node),
                    ...cast(typeMap.any),
                ]),
                order: (0, util_1.firstSplitTypeIndex)(typeMap.string),
            }];
    if (typeMap.number.length > 0 && typeMap.integer.length > 0) {
        typeMap.number = [{
                node: (0, intersect_const_enum_1.intersectConstEnum)([
                    ...typeMap.number.map(({ node }) => node),
                    ...cast(typeMap.integer),
                    ...cast(typeMap.any),
                ]),
                order: (0, util_1.firstSplitTypeIndex)(typeMap.number),
            }];
        typeMap.integer = [];
    }
    else if (typeMap.number.length > 1)
        typeMap.number = [{
                node: (0, intersect_const_enum_1.intersectConstEnum)([
                    ...typeMap.number.map(({ node }) => node),
                    ...cast(typeMap.any),
                ]),
                order: (0, util_1.firstSplitTypeIndex)(typeMap.number),
            }];
    else if (typeMap.integer.length > 1)
        typeMap.integer = [{
                node: (0, intersect_const_enum_1.intersectConstEnum)([
                    ...typeMap.integer.map(({ node }) => node),
                    ...cast(typeMap.any),
                ]),
                order: (0, util_1.firstSplitTypeIndex)(typeMap.integer),
            }];
    if (typeMap.or.length > 0)
        typeMap.or = typeMap.or.filter(({ node }) => node.or.length > 0);
    if (typeMap.and.length > 0)
        typeMap.and = typeMap.and
            .filter(({ node }) => node.and.length > 0);
    return (0, util_1.flattenSplitTypeValues)(typeMap);
}
