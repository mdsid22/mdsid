"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNodeDocument = exports.isNonNullable = exports.copyName = exports.firstSplitTypeIndex = exports.flattenSplitTypeValues = exports.splitTypes = exports.union = exports.intersection = exports.isEqual = exports.hasConstEnum = exports.constEnumTypes = exports.isPrimitiveType = exports.ensureArray = exports.uniq = void 0;
function uniq(arr) {
    return arr
        .filter((t, index) => {
        for (let i = 0; i < index; ++i) {
            const u = arr[i];
            if (isEqual(t, u))
                return false;
        }
        return true;
    });
}
exports.uniq = uniq;
function ensureArray(t) {
    if (t == null)
        return [];
    return Array.isArray(t) ? t : [t];
}
exports.ensureArray = ensureArray;
const isPrimitiveType = (node) => ["null", "string", "number", "integer", "boolean"].includes(node.type);
exports.isPrimitiveType = isPrimitiveType;
exports.constEnumTypes = new Set([
    'any',
    'string',
    'number',
    'integer',
    'boolean',
    'object',
    'array',
    'tuple',
    'ref'
]);
const hasConstEnum = (node) => exports.constEnumTypes.has(node.type);
exports.hasConstEnum = hasConstEnum;
function isEqual(a, b) {
    if (typeof a !== typeof b)
        return false;
    else if ((a === null) !== (b === null))
        return false;
    else if (a === null)
        return true;
    else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
            return false;
        return !a.some((value, index) => !isEqual(value, b[index]));
    }
    else if (Array.isArray(a) !== Array.isArray(b))
        return false;
    else if (typeof a === 'object') {
        const keysA = Object.keys(a).sort();
        const keysB = Object.keys(b).sort();
        if (!isEqual(keysA, keysB))
            return false;
        return !keysA.some(key => !isEqual(a[key], b[key]));
    }
    else
        return a === b;
}
exports.isEqual = isEqual;
function intersection(a, b) {
    const ret = [];
    a.forEach(aItem => {
        b.forEach(bItem => {
            if (isEqual(aItem, bItem))
                ret.push(aItem);
        });
    });
    return ret;
}
exports.intersection = intersection;
function union(a, b) {
    const ret = [...a];
    b.forEach(aItem => {
        const unique = !a.some(bItem => isEqual(aItem, bItem));
        if (unique)
            ret.push(aItem);
    });
    return ret;
}
exports.union = union;
// Split a set of types into individual sets per-type
function splitTypes(nodes) {
    const ret = {
        and: [],
        or: [],
        ref: [],
        any: [],
        null: [],
        string: [],
        number: [],
        integer: [],
        boolean: [],
        object: [],
        array: [],
        tuple: [],
    };
    nodes.forEach((node, index) => {
        if (node.type !== 'and' && node.type !== 'or'
            ||
                node.type === 'and' && node.and.length > 0
            ||
                node.type === 'or' && node.or.length > 0) {
            const nodeWithOrder = {
                node,
                order: index,
            };
            ret[node.type].push(nodeWithOrder);
        }
    });
    return ret;
}
exports.splitTypes = splitTypes;
function flattenSplitTypeValues(splitTypes) {
    return [].concat(Object.values(splitTypes)
        .flat()
        .sort((a, b) => a.order - b.order)
        .map(({ node }) => node));
}
exports.flattenSplitTypeValues = flattenSplitTypeValues;
function firstSplitTypeIndex(nodes) {
    return Math.min(...nodes.map(({ order }) => order));
}
exports.firstSplitTypeIndex = firstSplitTypeIndex;
function copyName(from, to) {
    return typeof from.name === 'undefined' ? to : { ...to, name: from.name };
}
exports.copyName = copyName;
function isNonNullable(t) {
    return t != null;
}
exports.isNonNullable = isNonNullable;
function isNodeDocument(t) {
    return Array.isArray(t.types);
}
exports.isNodeDocument = isNodeDocument;
