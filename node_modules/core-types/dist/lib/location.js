"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeLocations = exports.getPositionOffset = exports.locationToLineColumn = exports.positionToLineColumn = void 0;
const util_1 = require("./util");
function positionToLineColumn(text, pos) {
    const line = text.slice(0, pos).split("\n").length;
    const columnIndex = text.lastIndexOf("\n", pos);
    return columnIndex === -1
        ? { offset: pos, line, column: pos }
        : { offset: pos, line, column: pos - columnIndex };
}
exports.positionToLineColumn = positionToLineColumn;
function locationToLineColumn(text, loc) {
    if (typeof loc.start === 'object')
        return loc;
    return {
        start: typeof loc.start === 'undefined'
            ? undefined
            : positionToLineColumn(text, loc.start),
        ...(loc.end == null
            ? {}
            : { end: positionToLineColumn(text, loc.end) }),
    };
}
exports.locationToLineColumn = locationToLineColumn;
function getPositionOffset(pos) {
    if (typeof pos === 'undefined')
        return pos;
    else if (typeof pos === 'number')
        return pos;
    return pos.offset;
}
exports.getPositionOffset = getPositionOffset;
/**
 * Use the smallest {start} and the biggest {end} to make a range consiting of
 * all locations
 */
function mergeLocations(locations) {
    var _a, _b, _c;
    let low;
    let high;
    const getOffset = (loc) => typeof loc === 'number' ? loc : loc === null || loc === void 0 ? void 0 : loc.offset;
    locations
        .filter(util_1.isNonNullable)
        .forEach(({ start, end }) => {
        const startOffset = getOffset(start);
        const endOffset = getOffset(end);
        if (startOffset !== undefined) {
            if (!low
                ||
                    typeof low.location === 'number'
                        &&
                            low.location === startOffset
                ||
                    low.offset > startOffset)
                low = {
                    location: start,
                    offset: startOffset,
                };
        }
        if (endOffset !== undefined) {
            if (!high
                ||
                    typeof high.location === 'number'
                        &&
                            high.location === startOffset
                ||
                    high.offset < endOffset)
                high = {
                    location: end,
                    offset: endOffset,
                };
        }
    });
    const start = low === null || low === void 0 ? void 0 : low.location;
    const end = high === null || high === void 0 ? void 0 : high.location;
    if (typeof start === 'undefined' && typeof end === 'undefined')
        return undefined;
    if (typeof ((_a = start) === null || _a === void 0 ? void 0 : _a.offset) !== 'undefined'
        &&
            (typeof ((_b = end) === null || _b === void 0 ? void 0 : _b.offset) !== 'undefined'
                ||
                    typeof end === 'undefined'))
        return {
            start: start,
            end: end,
        };
    return {
        start: (_c = getOffset(start)) !== null && _c !== void 0 ? _c : 0,
        end: getOffset(end),
    };
}
exports.mergeLocations = mergeLocations;
