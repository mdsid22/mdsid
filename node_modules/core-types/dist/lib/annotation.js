"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.formatSee = exports.formatDefault = exports.formatExamples = exports.arrayOrSingle = exports.stripAnnotations = exports.stringifyAnnotations = exports.wrapWhitespace = exports.extractAnnotations = exports.mergeAnnotations = void 0;
const location_1 = require("./location");
const util_1 = require("./util");
function mergeAnnotations(nodes) {
    var _a;
    const nonEmpty = (t) => !!t;
    const join = (t, separator = '\n') => (0, util_1.uniq)(t.filter(nonEmpty)).join(separator).trim();
    const name = (_a = nodes.find(n => n.name)) === null || _a === void 0 ? void 0 : _a.name;
    const title = join(nodes.map(n => n.title), ', ');
    const description = join(nodes.map(n => n.description));
    const examples = (0, util_1.uniq)([].concat(...nodes.map(n => (0, util_1.ensureArray)(n.examples)))
        .filter(nonEmpty));
    const _default = join(nodes.map(n => n.default));
    const see = (0, util_1.uniq)([].concat(...nodes.map(n => (0, util_1.ensureArray)(n.see)))
        .filter(nonEmpty));
    const comment = join(nodes.map(n => n.comment));
    const loc = (0, location_1.mergeLocations)(nodes.map(n => n.loc));
    return {
        ...(name ? { name } : {}),
        ...(title ? { title } : {}),
        ...(description ? { description } : {}),
        ...(examples.length > 0
            ? { examples: arrayOrSingle(examples) }
            : {}),
        ...(_default ? { default: _default } : {}),
        ...(see.length > 0
            ? { see: arrayOrSingle(see) }
            : {}),
        ...(comment ? { comment } : {}),
        ...(loc ? { loc } : {}),
    };
}
exports.mergeAnnotations = mergeAnnotations;
function extractAnnotations(node) {
    const { title, description, examples, default: _default, comment, see, } = node;
    return {
        ...(title ? { title } : {}),
        ...(description ? { description } : {}),
        ...(examples ? { examples } : {}),
        ...(_default ? { default: _default } : {}),
        ...(comment ? { comment } : {}),
        ...(see ? { see } : {}),
    };
}
exports.extractAnnotations = extractAnnotations;
function wrapWhitespace(text) {
    if (!text.includes("\n"))
        return text.startsWith(" ") ? text : ` ${text}`;
    return [
        "*",
        text.split("\n").map(line => ` * ${line}`).join("\n"),
        " "
    ].join("\n");
}
exports.wrapWhitespace = wrapWhitespace;
function makeSafeComment(text) {
    return text.replace(/\*\//g, '*\\/');
}
function stringifyAnnotations(node, { includeComment = false, formatWhitespace = false, } = {}) {
    const { description, examples, default: _default, comment, see } = node;
    const fullComment = makeSafeComment([
        description,
        ...(examples == undefined ? [] : [
            formatExamples((0, util_1.ensureArray)(examples))
        ]),
        ...(_default === undefined ? [] : [
            formatDefault(_default)
        ]),
        ...(see == undefined ? [] : [
            formatSee((0, util_1.ensureArray)(see))
        ]),
        ...(includeComment ? [comment] : []),
    ]
        .filter(v => v)
        .join("\n\n")
        .trim());
    return formatWhitespace && fullComment
        ? wrapWhitespace(fullComment)
        : fullComment;
}
exports.stringifyAnnotations = stringifyAnnotations;
function stripAnnotations(node, recursive = true) {
    const { comment, description, default: _default, examples, see, title, ...rest } = node;
    const filteredNode = rest;
    if (recursive) {
        if (filteredNode.type === 'and')
            return {
                ...filteredNode,
                and: filteredNode.and.map(n => stripAnnotations(n, true)),
            };
        else if (filteredNode.type === 'or')
            return {
                ...filteredNode,
                or: filteredNode.or.map(n => stripAnnotations(n, true)),
            };
        else if (filteredNode.type === 'array')
            return {
                ...filteredNode,
                elementType: stripAnnotations(filteredNode.elementType, true),
            };
        else if (filteredNode.type === 'tuple')
            return {
                ...filteredNode,
                elementTypes: filteredNode.elementTypes.map(n => stripAnnotations(n, true)),
                additionalItems: typeof filteredNode.additionalItems === 'object'
                    ? stripAnnotations(filteredNode.additionalItems, true)
                    : filteredNode.additionalItems,
            };
        else if (filteredNode.type === 'object')
            return {
                ...filteredNode,
                properties: Object.fromEntries(Object.keys(filteredNode.properties).map(key => [
                    key,
                    {
                        ...filteredNode.properties[key],
                        node: stripAnnotations(filteredNode.properties[key].node, true),
                    }
                ])),
                additionalProperties: typeof filteredNode.additionalProperties === 'object'
                    ? stripAnnotations(filteredNode.additionalProperties, true)
                    : filteredNode.additionalProperties,
            };
    }
    return filteredNode;
}
exports.stripAnnotations = stripAnnotations;
function arrayOrSingle(arr) {
    if (arr.length === 1)
        return arr[0];
    return arr;
}
exports.arrayOrSingle = arrayOrSingle;
function formatExamples(examples) {
    const lines = examples.map(example => "@example\n" + indent(stringify(example).split("\n"), 4))
        .join("\n");
    return lines.trim();
}
exports.formatExamples = formatExamples;
function formatDefault(_default) {
    const lines = [
        "@default",
        indent(stringify(_default).split("\n"), 4)
    ]
        .join("\n");
    return lines.trim();
}
exports.formatDefault = formatDefault;
function formatSee(see) {
    const lines = see.map(see => "@see " + stringify(see))
        .join("\n");
    return lines.trim();
}
exports.formatSee = formatSee;
function stringify(value) {
    return typeof value === "string"
        ? value
        : JSON.stringify(value, null, 2);
}
exports.stringify = stringify;
function indent(lines, indent, bullet = false) {
    return lines
        .map((line, index) => {
        const prefix = index === 0 && bullet
            ? (' '.repeat(indent - 2) + "* ")
            : ' '.repeat(indent);
        return prefix + line;
    })
        .join("\n");
}
