"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertCoreTypesToJsonSchema = exports.decorateSchema = void 0;
const openapi_json_schema_1 = require("openapi-json-schema");
const core_types_1 = require("core-types");
const annotations_1 = require("./annotations");
function decorateSchema(schema, { filename, sourceFilename, userPackage, userPackageUrl, }, packageName = 'core-types-json-schema', packageUrl = 'https://github.com/grantila/core-types-json-schema') {
    var _a, _b;
    if (typeof filename !== 'undefined')
        (_a = schema.$id) !== null && _a !== void 0 ? _a : (schema.$id = filename);
    const onbehalf = !userPackage && !userPackageUrl
        ? ''
        : userPackage && userPackageUrl
            ? `${userPackage} (${userPackageUrl})`
            : userPackage ? userPackage : userPackageUrl;
    const fromFilenameComment = sourceFilename
        ? ` from ${sourceFilename}`
        : '';
    (_b = schema.$comment) !== null && _b !== void 0 ? _b : (schema.$comment = `Generated${fromFilenameComment} by ` +
        `${packageName} (${packageUrl})` +
        (onbehalf ? ` on behalf of ${onbehalf}` : ''));
}
exports.decorateSchema = decorateSchema;
function convertCoreTypesToJsonSchema(doc, options) {
    const { version, types } = doc;
    if (version !== 1)
        throw new core_types_1.UnsupportedError(`core-types version ${version} not supported`);
    const schema = {
        definitions: Object.fromEntries(types.map(node => [node.name, toJsonSchema(node)]))
    };
    decorateSchema(schema, options !== null && options !== void 0 ? options : {});
    return {
        data: schema,
        convertedTypes: types.map(({ name }) => name),
        notConvertedTypes: [],
    };
}
exports.convertCoreTypesToJsonSchema = convertCoreTypesToJsonSchema;
function isOnlyType(node) {
    const keys = Object.keys(node).sort();
    return keys.length === 1 && keys[0] === 'type' ||
        keys.length === 2 && keys[0] === 'title' && keys[1] === 'type';
}
/**
 * Convert an 'or' type to anyOf, but try to convert to a type array if
 * possible. This might improve further conversion to Open API (nullable).
 */
function toJsonSchemaUnion(node) {
    const anyOf = node.or.map(subNode => toJsonSchema(subNode));
    const ret = (0, annotations_1.annotateJsonSchema)(node, { anyOf });
    if (anyOf.length > 1 && !anyOf.some(n => !isOnlyType(n))) {
        delete ret.anyOf;
        ret.type = anyOf.map(({ type }) => type);
    }
    return ret;
}
function toJsonSchema(node) {
    if (node.type === 'any')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, {}));
    else if (node.type === 'null')
        return (0, annotations_1.annotateJsonSchema)(node, { type: 'null' });
    else if (node.type === 'boolean')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, { type: 'boolean' }));
    else if (node.type === 'string')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, { type: 'string' }));
    else if (node.type === 'number')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, { type: 'number' }));
    else if (node.type === 'integer')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, { type: 'integer' }));
    else if (node.type === 'and')
        return (0, annotations_1.annotateJsonSchema)(node, {
            allOf: node.and.map(subNode => toJsonSchema(subNode)),
        });
    else if (node.type === 'or')
        return toJsonSchemaUnion(node);
    else if (node.type === 'object') {
        const allKeys = Object.keys(node.properties);
        const required = allKeys
            .filter(prop => node.properties[prop].required);
        const properties = Object.fromEntries(allKeys
            .map(prop => [prop, toJsonSchema(node.properties[prop].node)]));
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, {
            type: 'object',
            ...(allKeys.length > 0 ? { properties } : {}),
            ...(required.length > 0 ? { required } : {}),
            ...(node.additionalProperties === true
                ? {}
                : !node.additionalProperties
                    ? { additionalProperties: false }
                    : {
                        additionalProperties: toJsonSchema(node.additionalProperties)
                    }),
        }));
    }
    else if (node.type === 'array')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, {
            type: 'array',
            items: toJsonSchema(node.elementType),
        }));
    else if (node.type === 'tuple')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, {
            type: 'array',
            items: node.elementTypes.map(item => toJsonSchema(item)),
            ...(node.additionalItems === true
                ? {}
                : !node.additionalItems
                    ? { additionalItems: false }
                    : { additionalItems: toJsonSchema(node.additionalItems) }),
            minItems: node.minItems,
        }));
    else if (node.type === 'ref')
        return (0, annotations_1.annotateJsonSchema)(node, constEnum(node, {
            $ref: (0, openapi_json_schema_1.encodeRefNameJsonSchema)(node.ref),
        }));
    else
        throw new core_types_1.UnsupportedError(`core-types node of type ${node.type} not supported`, node);
}
function constEnum(node, jsonSchema) {
    if (node.const !== undefined)
        return { ...jsonSchema, const: node.const };
    if (node.enum)
        return { ...jsonSchema, enum: node.enum };
    return jsonSchema;
}
