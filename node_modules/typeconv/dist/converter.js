"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeConverter = void 0;
const core_types_1 = require("core-types");
const file_1 = require("./file");
const error_1 = require("./error");
const format_graph_1 = require("./format-graph");
async function readSource(from, reader) {
    if (reader.managedRead) {
        const { filename } = from;
        if (!filename)
            throw new Error("Internal error, expected filename not data");
        return { filename };
    }
    return await (0, file_1.getSource)(from);
}
async function convertAny(data, reader, writer, format, readOpts, writeOpts) {
    if (format === 'ct') {
        const read = await reader.read(data, readOpts);
        const written = await writer.write(read.data, writeOpts);
        return {
            output: written.data,
            convertedTypes: read.convertedTypes,
            notConvertedTypes: read.notConvertedTypes,
            outConvertedTypes: written.convertedTypes,
            outNotConvertedTypes: written.notConvertedTypes,
        };
    }
    else {
        const read = await reader.shortcut[format](data, readOpts);
        const written = await writer.shortcut[format](read.data, writeOpts, reader);
        return {
            output: written.data,
            convertedTypes: read.convertedTypes,
            notConvertedTypes: read.notConvertedTypes,
            outConvertedTypes: written.convertedTypes,
            outNotConvertedTypes: written.notConvertedTypes,
        };
    }
}
function makeConverter(reader, writer, options) {
    const { shortcut = true, cwd = process.cwd() } = options !== null && options !== void 0 ? options : {};
    const relFilename = (filename) => (0, file_1.relFile)(options === null || options === void 0 ? void 0 : options.cwd, filename);
    const context = new format_graph_1.ConversionContext(reader, writer, { shortcut });
    const conversionPath = context.getPath();
    const simpleSingleConversion = conversionPath.length === 1 && conversionPath[0].format === 'ct';
    async function convert(from, to) {
        var _a, _b;
        const { data, filename } = await readSource(from, reader);
        const dataOrFilename = (data !== null && data !== void 0 ? data : filename);
        const warn = (msg, meta) => {
            const fullMeta = (0, core_types_1.decorateErrorMeta)({ ...meta }, { filename, source: data });
            console.warn((0, error_1.formatError)(msg, fullMeta));
        };
        const toFilename = (_a = to === null || to === void 0 ? void 0 : to.relFilename) !== null && _a !== void 0 ? _a : relFilename((_b = to === null || to === void 0 ? void 0 : to.filename) !== null && _b !== void 0 ? _b : '');
        const readOpts = {
            warn,
            filename: filename ? relFilename(filename) : undefined,
        };
        const writeOpts = {
            warn,
            ...(to
                ? { filename: toFilename }
                : {}),
            ...(filename
                ? { sourceFilename: relFilename(filename) }
                : {}),
            rawInput: data,
        };
        const convertByGraphPath = async (data, pathIndex) => {
            const { reader, writer, format } = conversionPath[pathIndex];
            const result = await convertAny(data, reader, writer, format, readOpts, writeOpts);
            const uniqAppend = (a, b) => [...new Set(a), ...new Set(b)];
            if (conversionPath.length > pathIndex + 1) {
                // Recurse - follow path and convert again
                const recursionResult = await convertByGraphPath(result.output, pathIndex + 1);
                return {
                    output: recursionResult.output,
                    convertedTypes: recursionResult.convertedTypes,
                    notConvertedTypes: uniqAppend(result.notConvertedTypes, recursionResult.notConvertedTypes),
                    outConvertedTypes: recursionResult.convertedTypes,
                    outNotConvertedTypes: uniqAppend(result.outNotConvertedTypes, recursionResult.outNotConvertedTypes),
                };
            }
            else {
                return result;
            }
        };
        const convertDefault = async () => {
            const { data: doc, convertedTypes, notConvertedTypes } = await reader.read(dataOrFilename, readOpts);
            const simplifiedDoc = (options === null || options === void 0 ? void 0 : options.simplify) === false
                ? doc
                : (0, core_types_1.simplify)(doc);
            const { map, filter, transform } = options !== null && options !== void 0 ? options : {};
            const mappedDoc = typeof map === 'function'
                ? {
                    ...simplifiedDoc,
                    types: doc.types.map((type, index) => map(type, index, doc.types)),
                }
                : simplifiedDoc;
            const filteredDoc = typeof filter === 'function'
                ? {
                    ...mappedDoc,
                    types: doc.types.filter((type, index) => filter(type, index, doc.types)),
                }
                : mappedDoc;
            const finalDoc = typeof transform === 'function'
                ? transform(filteredDoc)
                : filteredDoc;
            const { data: output, convertedTypes: outConvertedTypes, notConvertedTypes: outNotConvertedTypes } = await writer.write(finalDoc, writeOpts);
            return {
                output,
                convertedTypes,
                notConvertedTypes,
                outConvertedTypes,
                outNotConvertedTypes,
            };
        };
        try {
            const { output, convertedTypes, notConvertedTypes, outConvertedTypes, outNotConvertedTypes, } = simpleSingleConversion
                ? await convertDefault()
                : await convertByGraphPath(dataOrFilename, 0);
            const info = {
                in: { convertedTypes, notConvertedTypes },
                out: {
                    convertedTypes: outConvertedTypes,
                    notConvertedTypes: outNotConvertedTypes,
                },
            };
            if (typeof (to === null || to === void 0 ? void 0 : to.filename) === 'undefined')
                return { data: output, ...info };
            // Only write non-empty files
            if (outConvertedTypes.length > 0)
                await (0, file_1.writeFile)(to === null || to === void 0 ? void 0 : to.filename, output);
            return info;
        }
        catch (err) {
            if ((0, core_types_1.isCoreTypesError)(err))
                (0, core_types_1.decorateError)(err, {
                    source: data,
                    ...(filename ? { filename } : {}),
                });
            throw err;
        }
    }
    const fromFormat = reader.kind;
    return { convert: convert, cwd, fromFormat };
}
exports.makeConverter = makeConverter;
