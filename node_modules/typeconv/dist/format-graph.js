"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversionContext = exports.registerWriter = exports.registerReader = exports.FormatGraph = exports.makePathKey = void 0;
function makePathKey(path) {
    return path
        .map(({ format, reader, writer }) => `${reader.kind}->{${format}}->${writer.kind}`)
        .join('  ');
}
exports.makePathKey = makePathKey;
class FormatGraph {
    constructor() {
        // Maps from-type -> (type-type -> reader)
        this.readerGraph = new Map();
        // Maps from-type -> (type-type -> writer)
        this.writerGraph = new Map();
    }
    registerReader(reader) {
        var _a;
        const toMap = [
            ['ct', reader],
            ...Object
                .keys((_a = reader.shortcut) !== null && _a !== void 0 ? _a : {})
                .map((key) => [key, reader]),
        ];
        this.readerGraph.set(reader.kind, new Map(toMap));
    }
    registerWriter(writer) {
        var _a;
        const makeTo = () => [writer.kind, writer];
        const insertWriter = (from) => {
            var _a;
            const old = [...(_a = this.writerGraph.get(from)) !== null && _a !== void 0 ? _a : []];
            this.writerGraph.set(from, new Map([...old, makeTo()]));
        };
        insertWriter('ct');
        Object
            .keys((_a = writer.shortcut) !== null && _a !== void 0 ? _a : {})
            .forEach(key => insertWriter(key));
    }
    findAllPaths(reader, writer, shortcuts) {
        const paths = new Map();
        const appendSet = (set, val) => new Set([...set, val]);
        const recurse = (reader, path, opts) => {
            var _a, _b, _c;
            const { allowManaged = false, cache } = opts;
            const handleFound = (writer, format) => {
                if (reader.managedRead && !allowManaged)
                    return;
                const newPath = [...path, { reader, writer, format }];
                const pathKey = makePathKey(newPath);
                paths.set(pathKey, newPath);
            };
            const formats = [
                ...shortcuts ? [] : ['ct'],
                ...shortcuts !== false
                    ? Object.keys((_a = reader.shortcut) !== null && _a !== void 0 ? _a : {})
                    : []
            ];
            for (const format of formats) {
                const writers = this.writerGraph.get(format);
                for (const [to, _writer] of (_b = writers === null || writers === void 0 ? void 0 : writers.entries()) !== null && _b !== void 0 ? _b : []) {
                    if (writer.kind === _writer.kind)
                        handleFound(writer, format);
                    else if (reader.kind === _writer.kind)
                        continue;
                    else {
                        // Find readers and recurse
                        const readers = this.readerGraph.get(to);
                        for (const _reader of (_c = readers === null || readers === void 0 ? void 0 : readers.values()) !== null && _c !== void 0 ? _c : []) {
                            if (_reader.managedRead && !allowManaged)
                                continue;
                            else if (cache.has(_reader))
                                continue; // Cyclic
                            recurse(_reader, [...path, { reader, writer: _writer, format }], {
                                cache: appendSet(cache, _reader),
                            });
                        }
                    }
                }
            }
        };
        recurse(reader, [], { allowManaged: true, cache: new Set() });
        return [...paths.values()].sort((a, b) => a.length - b.length);
    }
    findBestPath(reader, writer, shortcut) {
        const paths = this.findAllPaths(reader, writer, shortcut);
        if (paths.length > 0)
            return paths[0];
        // Allow all, find shortest path
        return this.findAllPaths(reader, writer, undefined)[0];
    }
    clone() {
        const clone = new FormatGraph();
        const readers = [...this.readerGraph.values()]
            .flatMap(map => [...map.values()]);
        const writers = [...this.writerGraph.values()]
            .flatMap(map => [...map.values()]);
        readers.forEach(reader => clone.registerReader(reader));
        writers.forEach(writer => clone.registerWriter(writer));
        return clone;
    }
}
exports.FormatGraph = FormatGraph;
const defaultGraph = new FormatGraph();
function registerReader(reader) {
    defaultGraph.registerReader(reader);
}
exports.registerReader = registerReader;
function registerWriter(writer) {
    defaultGraph.registerWriter(writer);
}
exports.registerWriter = registerWriter;
class ConversionContext {
    constructor(reader, writer, opts = {}) {
        this.reader = reader;
        this.writer = writer;
        this.shortcut = opts.shortcut;
        this.graph = defaultGraph.clone();
        this.graph.registerReader(reader);
        this.graph.registerWriter(writer);
    }
    getPath() {
        return this.graph.findBestPath(this.reader, this.writer, this.shortcut);
    }
}
exports.ConversionContext = ConversionContext;
