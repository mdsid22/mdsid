"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.batchConvertGlob = exports.batchConvert = void 0;
const path = require("path");
const already_1 = require("already");
const chalk = require("chalk");
const file_1 = require("./file");
async function batchConvert(converter, filenames, options) {
    const { outputExtension, verbose, dryRun, 
    // Not really CPU concurrency in this case, but enough I/O concurrency
    // to always have files prepared/read/written for CPU-bound conversion.
    // Set to 1 for deterministic unit tests.
    concurrency = 16 } = options;
    const { cwd, convert, fromFormat } = converter;
    const { root, newRoot, files } = (0, file_1.reRootFiles)(filenames, cwd, options.outputDirectory);
    if (verbose) {
        console.error(`Converting files relative to ${root}`);
        if (newRoot !== root)
            console.error(`Storing files in ${newRoot}`);
    }
    const innerExtension = fromFormat === 'ts'
        ? '.d'
        : undefined;
    const changeExt = (outFile, outExt) => changeExtension(outFile, outExt, innerExtension);
    const firstOverwritten = files.find(file => file.in === changeExt(file.out, outputExtension));
    if (outputExtension !== '-' && firstOverwritten)
        throw new Error("Won't convert - would overwrite source file with target file: " +
            firstOverwritten.out);
    let convertedTypes = 0;
    await (0, already_1.map)(files, { concurrency }, async ({ in: filename, out: outFilename, rel }) => {
        const to = (dryRun || outputExtension === '-')
            ? undefined
            : {
                filename: changeExt(outFilename, outputExtension),
                relFilename: changeExt(rel, outputExtension),
            };
        const { data, ...info } = await convert({ filename, cwd }, to);
        convertedTypes += info.out.convertedTypes.length;
        if (verbose) {
            const outputRel = changeExt(rel, outputExtension);
            const outName = outputExtension === '-' ? 'stdout' : outputRel;
            const allInputTypes = info.in.convertedTypes.length +
                info.in.notConvertedTypes.length;
            const notConverted = info.in.notConvertedTypes.length +
                info.out.notConvertedTypes.length;
            const converted = info.out.convertedTypes.length;
            const percent = allInputTypes === 0
                ? 'no'
                : `${Math.round(converted * 100 / allInputTypes)}%`;
            const prefixText = '[typeconv]';
            const prefix = allInputTypes === 0
                ? chalk.gray(prefixText)
                : notConverted
                    ? chalk.hex('#D2D200')(prefixText)
                    : chalk.hex('#00D21F')(prefixText);
            console.error(`${prefix} ${(0, file_1.prettyFile)(rel, root)} -> ` +
                `${(0, file_1.prettyFile)(outName, newRoot)}, ${percent} types ` +
                `converted (${converted}/${allInputTypes})` +
                (!notConverted ? '' : `, ${notConverted} rejected`));
        }
        if (outputExtension === '-' && !dryRun)
            console.log(data);
    });
    return {
        types: convertedTypes,
        files: files.length,
    };
}
exports.batchConvert = batchConvert;
async function batchConvertGlob(converter, globs, options) {
    const { hidden, filesTransform = v => v } = options;
    const { cwd } = converter;
    const files = await (0, file_1.glob)(globs, cwd, hidden);
    return batchConvert(converter, filesTransform(files), options);
}
exports.batchConvertGlob = batchConvertGlob;
function changeExtension(filename, extension, innerExtension) {
    extension = extension.startsWith('.') ? extension : `.${extension}`;
    const baseName = path.basename(filename, path.extname(filename));
    const innerName = innerExtension
        ? path.basename(baseName, innerExtension)
        : baseName;
    return path.join(path.dirname(filename), innerName + extension);
}
