"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prettyFile = exports.reRootFiles = exports.getRootFolderOfFiles = exports.ensureAbsolute = exports.glob = exports.relFile = exports.writeFile = exports.getSource = void 0;
const fs_1 = require("fs");
const path = require("path");
const globby = require("globby");
const chalk_1 = require("chalk");
const terminalLink = require("terminal-link");
async function getSource(source) {
    if (source.data)
        return {
            data: source.data,
        };
    else if (source.filename && fs_1.promises.readFile)
        return {
            data: await fs_1.promises.readFile(source.filename, 'utf-8'),
            filename: source.filename,
        };
    throw new Error("Invalid source: " + JSON.stringify(source));
}
exports.getSource = getSource;
async function writeFile(filename, data) {
    const tryWrite = () => fs_1.promises.writeFile(filename, data);
    try {
        await tryWrite();
    }
    catch (err) {
        if ((err === null || err === void 0 ? void 0 : err.code) === 'ENOENT') {
            await fs_1.promises.mkdir(path.dirname(filename), { recursive: true });
            await tryWrite();
        }
    }
}
exports.writeFile = writeFile;
function relFile(from, to) {
    if (typeof from === 'undefined')
        return to;
    return path.relative(from, to);
}
exports.relFile = relFile;
async function glob(globs, cwd, hidden = true) {
    const patterns = hidden ? [...globs, '!.git'] : globs;
    const dot = !hidden;
    const gitignore = hidden;
    return globby(patterns, { cwd, dot, gitignore });
}
exports.glob = glob;
function ensureAbsolute(filename, cwd) {
    return path.isAbsolute(filename)
        ? filename
        : path.normalize(path.join(cwd, filename));
}
exports.ensureAbsolute = ensureAbsolute;
/**
 * Find the deepest common directory of a set of files.
 */
function getRootFolderOfFiles(files, cwd) {
    const map = {};
    const last = new WeakMap();
    files
        .map(filename => ensureAbsolute(filename, cwd))
        .map(filename => path.dirname(filename))
        .forEach(dirname => {
        const dirSegments = dirname.split(path.sep);
        let cur = map;
        dirSegments.forEach(segment => {
            var _a;
            (_a = cur[segment]) !== null && _a !== void 0 ? _a : (cur[segment] = {});
            cur = cur[segment];
        });
        last.set(cur, dirname);
    });
    let curPath = [];
    let cur = map;
    while (true) {
        const keys = Object.getOwnPropertyNames(cur);
        if (keys.length !== 1)
            return curPath.join(path.sep);
        else if (last.has(cur))
            return last.get(cur);
        cur = cur[keys[0]];
        curPath.push(keys[0]);
    }
}
exports.getRootFolderOfFiles = getRootFolderOfFiles;
/**
 * Get the common "root" directory of files, their relative path to this
 * directory, and their relative path to new root directory.
 */
function reRootFiles(files, cwd, newRoot) {
    const root = getRootFolderOfFiles(files, cwd);
    const newAbsRoot = typeof newRoot === 'undefined'
        ? root
        : ensureAbsolute(newRoot, cwd);
    return {
        root,
        newRoot: newAbsRoot,
        files: files
            .map(filename => ensureAbsolute(filename, cwd))
            .map(filename => {
            const rel = path.relative(root, filename);
            const out = ensureAbsolute(rel, newAbsRoot);
            return { in: filename, out, rel };
        }),
    };
}
exports.reRootFiles = reRootFiles;
function prettyFile(filename, cwd) {
    const absFile = 'file://' + ensureAbsolute(filename, cwd);
    const baseName = path.basename(filename);
    const dirName = path.dirname(filename);
    const name = ((dirName && dirName !== '.') ? (dirName + path.sep) : '') +
        (0, chalk_1.bold)(baseName);
    return terminalLink(name, absFile, { fallback: false });
}
exports.prettyFile = prettyFile;
